import {make_point, x_of, y_of, arc, translate, draw_connected, make_color_point, make_3D_color_point, draw_3D_connected_full_view,draw_3D_connected_full_view_proportional,  draw_connected_full_view, unit_circle, unit_line, draw_points, rotate_around_origin, draw_connected_full_view_proportional, draw_points_full_view} from "curve";

// unit_circle_2 takes in some t
// and returns a point (cos(2 pi t), sin(2 pi t))
function unit_circle_2(t) {
    return make_point(math_cos(2 * math_PI * t),
                      math_sin(2 * math_PI * t));
}

function unit_line_2(t) {
    return make_point(t, 0.5);
}

// Try to adjust the value passed to "draw_points"
// The positions of points changes. 
// 1: t = 0, t = 1 <both endpoints>
// 2: t = 0, t = 0.5, t = 1
// 3: t = 0, t = 0.33, t = 0.66, t = 1
draw_points(2)(unit_line_2); // Call 1

// Try to adjust the value passed to "draw_points_full_view"
// The positions of points changes. 
// 1: t = 0, t = 1 <both endpoints>
// 2: t = 0.2, ?
// 3: 3 points
draw_points_full_view(3)(unit_circle_2); // Call 2

// We use draw_connected to create line segments
// Lines are drawn between the points
// 1: one line between t = 0, t = 1 
// 2: one horizontal line (no closed shape between two lines)
// 3: a triangle 
// 200: Sufficiently large to generate the complete circle
draw_connected_full_view_proportional(200)(unit_circle_2); // Call 3

// Spiral Curves
// Idea is to make use of unit_circle points, but multiply t to the x and y coords
// of the point p from unit circle, such that the distance from origin increases
function spiral_one(t) {
    const p = unit_circle(t);
    return make_point(t * x_of(p), t * y_of(p));
}

draw_connected_full_view_proportional(200)(spiral_one); // Call 4

// Note that draw_connected takes in function that only has one parameter
// If we need more than one parameter, we have to introduce helper or nested functions


function spiral(rev) { // Return a spiral with some number of revolutions
    return t => {
        // p must be defined in this block, not outside, because it relies on t
        const p = unit_circle((t * rev) % 1); 
        // Multiply t by rev, such that the range of t*rev is [0, rev]
        // * 1 such that we are still returning [0, 1], BUT the value of t
        // goes through rev rounds from 0 to 1 and back to 0
        
        // E.g. rev = 5
        // t = 0 unit_circle(0)         rd 1
        // t = 0.1 unit_circle(0.5)     rd 1
        // t = 0.19 unit_circle(0.95)   rd 1
        // t = 0.2 unit_circle(0)       rd 2
        // t = 0.3 unit_circle(0.5)     rd 2
        // t = 0.39 unit_circle(0.95)   rd 2
        // ...
        // t = 0.99 unit_circle(0.95)   rd 5
        return make_point(t * x_of(p), t * y_of(p)); 
        // REMEMBER RETURN : when using t => { ... } form
    };
}

draw_connected_full_view(2000)(spiral(33));  // Call 5

// Drawing 3D curves
draw_3D_connected_full_view(2000)(spiral(33)); // Call 6
// We see that the spiral is in a 2D plane.

// Rotate_around_origin takes in theta1, theta2 and theta3. 
// Then it returns line rotated around origin by (theta1) rad about x-axis
// (theta2) rad about y-axis, (theta3) rad about z-axis
// Hence changing theta1 and theta2 does not produce viewable results on a 2D screen

const rot_line = rotate_around_origin(1, 1, 0)(unit_line); 
draw_connected_full_view_proportional(200)(rot_line); // Call 7
draw_3D_connected_full_view_proportional(200)(rot_line); // Call 8

const shifted_rot_line = translate(0, 0.25, 0)(rot_line);
draw_connected(200)(shifted_rot_line); // Call 9

function connect_rigidly(curve1, curve2) {
    return t => t < 1/2
                ? curve1(2 * t)
                : curve2(2 * t - 1);
}
const result_curve = connect_rigidly(arc, translate(1, 0, 0)(arc)); // Call 10
draw_connected_full_view_proportional(2000)(result_curve);

function colorful_spiral(rev) {
    return t => {
        const p = unit_circle((t * rev) % 1);
        const R = math_max(0, 1 - 2 * t) * 255;
        const G = (1 - math_abs(1 - 2 * t)) * 255;
        const B = math_max(0, 2 * t - 1) * 255;
        
        return make_color_point(t * x_of(p), t * y_of(p), R, G, B);
    };
}

function colorful_3D_spiral(rev) {
    return t => {
        const p = unit_circle((t * rev) % 1);
        const R = math_max(0, 1 - 2 * t) * 255;
        const G = (1 - math_abs(1 - 2 * t)) * 255;
        const B = math_max(0, 2 * t - 1) * 255;
        
        return make_3D_color_point(t * x_of(p), t * y_of(p), 2 * t, R, G, B);
    };
}

draw_connected_full_view_proportional(2000)(colorful_spiral(10)); // Call 11
draw_3D_connected_full_view_proportional(2000)(colorful_3D_spiral(10)); // Call 12


import {make_sound, play} from "sound";

// Sound waves are generated by sin curves
// sin (2 * pi * f * t) from t=0 to t=1 generates a sound wave of frequency f
// pitch_A_wave is of frequency 440Hz
const pitch_A_wave = t => math_sin(2 * math_PI * 440 * t);

// C major chord is formed by C4, E4 and G4
// Adjusting the numbers "0.33" adjusts the "proportion" of each member wave
// Increasing all by the same scale (e.g. 0.33 --> 1) increases loudness of wave
const C_maj_chord_wave =
    t => 1 * math_sin(2 * math_PI * 261.63 * t) +   // C4
         1 * math_sin(2 * math_PI * 329.63 * t) +   // E4
         1 * math_sin(2 * math_PI * 392.00 * t);    // G4
         
const C_maj_chord = make_sound(C_maj_chord_wave, 1.5); // makes Sound lasting 1.5 seconds
// In the case of sound waves, the number of seconds denotes the range of t
// 1.5 means t increases from t=0 to t=1.5

play(C_maj_chord); // plays Sound Call 1

const doremi_wave =
    t => t < 0.5
         ? math_sin(2 * math_PI * 261.63 * t) // play C4 for t=0 to t=0.5
         : t < 1.0
         ? math_sin(2 * math_PI * 293.66 * t) // play D4 for t=0.5 to t=1
         : math_sin(2 * math_PI * 329.63 * t); // play E4 for t=1 to t=1.5


const doremi = make_sound(doremi_wave, 1.5); 
play(doremi); // plays Sound Call 2